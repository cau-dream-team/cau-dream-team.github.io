<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-13T00:45:27.003409961"><title>02. Lexical Analyzer 1 | Compiler</title><script type="application/json" id="virtual-toc-data">[{"id":"starters","level":0,"title":"Starters","anchor":"#starters"},{"id":"overview","level":0,"title":"Overview","anchor":"#overview"},{"id":"tokens-patterns-and-lexemes","level":0,"title":"Tokens, Patterns, and Lexemes","anchor":"#tokens-patterns-and-lexemes"},{"id":"role-of-lexical-analyzer","level":0,"title":"Role of Lexical Analyzer","anchor":"#role-of-lexical-analyzer"},{"id":"specification-of-tokens","level":0,"title":"Specification of Tokens","anchor":"#specification-of-tokens"},{"id":"alphabets-strings-and-languages","level":0,"title":"Alphabets, Strings, and Languages","anchor":"#alphabets-strings-and-languages"},{"id":"regular-expressions-res","level":0,"title":"Regular Expressions (REs)","anchor":"#regular-expressions-res"},{"id":"finite-automata","level":0,"title":"Finite Automata","anchor":"#finite-automata"},{"id":"dfas-vs-nfas","level":0,"title":"DFAs vs. NFAs","anchor":"#dfas-vs-nfas"},{"id":"thompson-s-construction-re-nfa","level":0,"title":"Thompson\u0027s Construction (RE → NFA)","anchor":"#thompson-s-construction-re-nfa"},{"id":"subset-construction-nfa-dfa","level":0,"title":"Subset Construction (NFA → DFA)","anchor":"#subset-construction-nfa-dfa"},{"id":"implementing-lexical-analyzers","level":0,"title":"Implementing Lexical Analyzers","anchor":"#implementing-lexical-analyzers"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="02. Lexical Analyzer 1 | Compiler"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Compiler Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/compiler/compiler-02.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="02. Lexical Analyzer 1 | Compiler"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/compiler/compiler-02.html#webpage",
    "url": "writerside-documentation/compiler/compiler-02.html",
    "name": "02. Lexical Analyzer 1 | Compiler",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationcompiler/#website",
    "url": "writerside-documentationcompiler/",
    "name": "Compiler Help"
}</script><!-- End Schema.org --></head><body data-id="compiler-02" data-main-title="02. Lexical Analyzer 1" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Weeks"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Compiler  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="compiler-02" id="compiler-02.md">02. Lexical Analyzer 1</h1><p id="z98xrh4_3">Lexical analysis is the first phase of a compiler, responsible for breaking down the source code into meaningful tokens. This process transforms a character stream into a token stream that can be processed by the parser.</p><section class="chapter"><h2 id="starters" data-toc="starters">Starters</h2><ul class="list _bullet" id="z98xrh4_16"><li class="list__item" id="z98xrh4_17"><p>Structure of Compilers</p></li><li class="list__item" id="z98xrh4_18"><p>Lexical analyzer (scanner): groups characters into tokens (meaningful sequences)</p></li><li class="list__item" id="z98xrh4_19"><p>Examples of Tokenization (Practice)</p></li></ul></section><section class="chapter"><h2 id="overview" data-toc="overview">Overview</h2><p id="z98xrh4_20">To build a scanner, we need to learn:</p><ul class="list _bullet" id="z98xrh4_21"><li class="list__item" id="z98xrh4_22"><p><span class="control" id="z98xrh4_26">Concepts</span>: Tokens, Patterns, Lexemes</p></li><li class="list__item" id="z98xrh4_23"><p><span class="control" id="z98xrh4_27">How to depict patterns</span>: </p><ul class="list _bullet" id="z98xrh4_28"><li class="list__item" id="z98xrh4_29"><p>Regular Languages</p></li><li class="list__item" id="z98xrh4_30"><p>Operations on strings &amp; languages</p></li><li class="list__item" id="z98xrh4_31"><p>Regular Expressions (REs)</p></li></ul></li><li class="list__item" id="z98xrh4_24"><p><span class="control" id="z98xrh4_32">How to recognize patterns</span>: </p><ul class="list _bullet" id="z98xrh4_33"><li class="list__item" id="z98xrh4_34"><p>Finite Automata (DFAs, NFAs)</p></li></ul></li><li class="list__item" id="z98xrh4_25"><p><span class="control" id="z98xrh4_35">How to implement a scanner</span>: </p><ul class="list _bullet" id="z98xrh4_36"><li class="list__item" id="z98xrh4_37"><p>Token patterns &rarr; REs</p></li><li class="list__item" id="z98xrh4_38"><p>REs &rarr; NFAs: Thompson's Construction</p></li><li class="list__item" id="z98xrh4_39"><p>NFAs &rarr; DFAs: Subset Construction</p></li></ul></li></ul></section><section class="chapter"><h2 id="tokens-patterns-and-lexemes" data-toc="tokens-patterns-and-lexemes">Tokens, Patterns, and Lexemes</h2><section class="chapter"><h3 id="definition_1" data-toc="definition_1">Definition</h3><p id="z98xrh4_42">A token is a basic unit of syntax in programming languages. Formally, a token is represented by a tuple ``:</p><ul class="list _bullet" id="z98xrh4_43"><li class="list__item" id="z98xrh4_46"><p><code class="code" id="z98xrh4_48">token_name</code> represents a type of lexical unit</p></li><li class="list__item" id="z98xrh4_47"><p><code class="code" id="z98xrh4_49">value</code> is optional; it contains the attribute values of the token</p></li></ul><p id="z98xrh4_44">For example, in the expression <code class="code" id="z98xrh4_50">a = b * 2</code>, the tokens would be:</p><div class="code-block" data-lang="none">
&lt;id, a&gt; &lt;assign&gt; &lt;id, b&gt; &lt;multiply&gt; &lt;number, 2&gt;
</div></section><section class="chapter"><h3 id="classes-of-token-name" data-toc="classes-of-token-name">Classes of token_name</h3><ul class="list _bullet" id="z98xrh4_51"><li class="list__item" id="z98xrh4_53"><p><span class="control" id="z98xrh4_59">Keywords</span>: pre-defined strings (if, else, float)</p></li><li class="list__item" id="z98xrh4_54"><p><span class="control" id="z98xrh4_60">Identifiers</span>: user-defined identifiers</p></li><li class="list__item" id="z98xrh4_55"><p><span class="control" id="z98xrh4_61">Constants</span>: numeric constants</p></li><li class="list__item" id="z98xrh4_56"><p><span class="control" id="z98xrh4_62">Operators</span>: assign (=), comparison (, ==)</p></li><li class="list__item" id="z98xrh4_57"><p><span class="control" id="z98xrh4_63">Punctuation symbols</span>: parentheses, commas</p></li><li class="list__item" id="z98xrh4_58"><p><span class="control" id="z98xrh4_64">Whitespaces</span>: blank, tab, newline</p></li></ul><p id="z98xrh4_52">A pattern is a rule describing the set of strings of a particular token, while a lexeme is a sequence of characters that matches the pattern for a token (an instance of a token).</p></section></section><section class="chapter"><h2 id="role-of-lexical-analyzer" data-toc="role-of-lexical-analyzer">Role of Lexical Analyzer</h2><p id="z98xrh4_65">The lexical analyzer:</p><ul class="list _bullet" id="z98xrh4_66"><li class="list__item" id="z98xrh4_67"><p>Recognizes correct tokens from the source program</p></li><li class="list__item" id="z98xrh4_68"><p>Passes tokens to the parser (syntax analyzer)</p></li><li class="list__item" id="z98xrh4_69"><p>Enters discovered lexemes into the symbol table for parser use</p></li></ul></section><section class="chapter"><h2 id="specification-of-tokens" data-toc="specification-of-tokens">Specification of Tokens</h2><p id="z98xrh4_70">Regular languages provide a simple yet powerful way to describe patterns of tokens.</p></section><section class="chapter"><h2 id="alphabets-strings-and-languages" data-toc="alphabets-strings-and-languages">Alphabets, Strings, and Languages</h2><ul class="list _bullet" id="z98xrh4_71"><li class="list__item" id="z98xrh4_74"><p><span class="control" id="z98xrh4_77">Alphabet</span>: a finite, non-empty set of symbols</p></li><li class="list__item" id="z98xrh4_75"><p><span class="control" id="z98xrh4_78">String</span>: a finite sequence of symbols from the alphabet</p></li><li class="list__item" id="z98xrh4_76"><p><span class="control" id="z98xrh4_79">Language</span>: a set of strings over an alphabet</p></li></ul><section class="chapter"><h3 id="string-operations" data-toc="string-operations">String Operations</h3><div class="table-wrapper"><table class="wide" id="z98xrh4_80"><thead><tr class="ijRowHead" id="z98xrh4_81"><th id="z98xrh4_87"><p>Notation</p></th><th id="z98xrh4_88"><p>Name</p></th><th id="z98xrh4_89"><p>Definition</p></th><th id="z98xrh4_90"><p>Examples</p></th></tr></thead><tbody><tr id="z98xrh4_82"><td id="z98xrh4_91"><p>s</p></td><td id="z98xrh4_92"><p>String</p></td><td id="z98xrh4_93"><p>A finite sequence of symbols</p></td><td id="z98xrh4_94"></td></tr><tr id="z98xrh4_83"><td id="z98xrh4_95"><p>\|s\|</p></td><td id="z98xrh4_96"><p>Length</p></td><td id="z98xrh4_97"><p>Number of symbols in s</p></td><td id="z98xrh4_98"></td></tr><tr id="z98xrh4_84"><td id="z98xrh4_99"><p>s₁s₂</p></td><td id="z98xrh4_100"><p>Concatenation</p></td><td id="z98xrh4_101"><p>Writing one string after another</p></td><td id="z98xrh4_102"></td></tr><tr id="z98xrh4_85"><td id="z98xrh4_103"><p>&epsilon;</p></td><td id="z98xrh4_104"><p>Empty String</p></td><td id="z98xrh4_105"><p>A string with no symbols</p></td><td id="z98xrh4_106"></td></tr><tr id="z98xrh4_86"><td id="z98xrh4_107"><p>sⁿ</p></td><td id="z98xrh4_108"><p>Exponentiation</p></td><td id="z98xrh4_109"><p>Concatenation of s for n times</p></td><td id="z98xrh4_110"></td></tr></tbody></table></div></section><section class="chapter"><h3 id="language-operations" data-toc="language-operations">Language Operations</h3><div class="table-wrapper"><table class="wide" id="z98xrh4_111"><thead><tr class="ijRowHead" id="z98xrh4_112"><th id="z98xrh4_121"><p>Notation</p></th><th id="z98xrh4_122"><p>Name</p></th><th id="z98xrh4_123"><p>Definition</p></th></tr></thead><tbody><tr id="z98xrh4_113"><td id="z98xrh4_124"><p>L</p></td><td id="z98xrh4_125"><p>Language</p></td><td id="z98xrh4_126"><p>A set of strings on an alphabet</p></td></tr><tr id="z98xrh4_114"><td id="z98xrh4_127"><p>&empty;</p></td><td id="z98xrh4_128"><p>Empty set</p></td><td id="z98xrh4_129"><p>A set without any elements</p></td></tr><tr id="z98xrh4_115"><td id="z98xrh4_130"><p>L₁ &cup; L₂</p></td><td id="z98xrh4_131"><p>Union</p></td><td id="z98xrh4_132"><p>s &isin; L₁ or s &isin; L₂</p></td></tr><tr id="z98xrh4_116"><td id="z98xrh4_133"><p>L₁ &cap; L₂</p></td><td id="z98xrh4_134"><p>Intersection</p></td><td id="z98xrh4_135"><p>s &isin; L₁ and s &isin; L₂</p></td></tr><tr id="z98xrh4_117"><td id="z98xrh4_136"><p>L₁ - L₂</p></td><td id="z98xrh4_137"><p>Difference</p></td><td id="z98xrh4_138"><p>s &isin; L₁ and s &notin; L₂</p></td></tr><tr id="z98xrh4_118"><td id="z98xrh4_139"><p>L₁L₂</p></td><td id="z98xrh4_140"><p>Concatenation</p></td><td id="z98xrh4_141"><p>{xy \| x &isin; L₁, y &isin; L₂}</p></td></tr><tr id="z98xrh4_119"><td id="z98xrh4_142"><p>L*</p></td><td id="z98xrh4_143"><p>Kleene closure</p></td><td id="z98xrh4_144"><p>Concatenation of L zero or more times</p></td></tr><tr id="z98xrh4_120"><td id="z98xrh4_145"><p>L⁺</p></td><td id="z98xrh4_146"><p>Positive closure</p></td><td id="z98xrh4_147"><p>Concatenation of L one or more times</p></td></tr></tbody></table></div></section></section><section class="chapter"><h2 id="regular-expressions-res" data-toc="regular-expressions-res">Regular Expressions (REs)</h2><p id="z98xrh4_148">Regular expressions are a powerful way to describe patterns of tokens. They combine:</p><ul class="list _bullet" id="z98xrh4_149"><li class="list__item" id="z98xrh4_153"><p>Strings of symbols from alphabet</p></li><li class="list__item" id="z98xrh4_154"><p>Parentheses</p></li><li class="list__item" id="z98xrh4_155"><p>Concatenation</p></li><li class="list__item" id="z98xrh4_156"><p>Operators (union and Kleene-closure)</p></li></ul><section class="chapter"><h3 id="definition_2" data-toc="definition_2">Definition</h3><p id="z98xrh4_157">Let &Sigma; be a given alphabet. Then:</p><ol class="list _decimal" id="z98xrh4_158" type="1"><li class="list__item" id="z98xrh4_159"><p>&empty;, &epsilon;, and a (for all a &isin; &Sigma;) are all regular expressions (primitive REs)</p></li><li class="list__item" id="z98xrh4_160"><p>If r₁ and r₂ are regular expressions, so are: </p><ul class="list _bullet" id="z98xrh4_161"><li class="list__item" id="z98xrh4_162"><p>(r₁)</p></li><li class="list__item" id="z98xrh4_163"><p>r₁|r₂ (union)</p></li><li class="list__item" id="z98xrh4_164"><p>r₁r₂ (concatenation)</p></li><li class="list__item" id="z98xrh4_165"><p>r₁* (Kleene closure)</p></li></ul></li></ol></section><section class="chapter"><h3 id="precedence-rules" data-toc="precedence-rules">Precedence Rules</h3><p id="z98xrh4_166">To disambiguate REs, the precedence order is:</p><ol class="list _decimal" id="z98xrh4_167" type="1"><li class="list__item" id="z98xrh4_168"><p>Parentheses</p></li><li class="list__item" id="z98xrh4_169"><p>Kleene closure (*)</p></li><li class="list__item" id="z98xrh4_170"><p>Concatenation</p></li><li class="list__item" id="z98xrh4_171"><p>Union (|)</p></li></ol></section><section class="chapter"><h3 id="extensions-of-res-shorthand-notations" data-toc="extensions-of-res-shorthand-notations">Extensions of REs (Shorthand Notations)</h3><ul class="list _bullet" id="z98xrh4_172"><li class="list__item" id="z98xrh4_173"><p>One or more instances: r⁺ = rr*</p></li><li class="list__item" id="z98xrh4_174"><p>Zero or one instance: r? = (r|&epsilon;)</p></li><li class="list__item" id="z98xrh4_175"><p>Character classes: [abc] = (a|b|c)</p></li><li class="list__item" id="z98xrh4_176"><p>Range notation: [a-z] = (a|b|...|z)</p></li></ul></section></section><section class="chapter"><h2 id="finite-automata" data-toc="finite-automata">Finite Automata</h2><p id="z98xrh4_177">An automaton is an abstract model of a digital computer. Finite automata are one of the simplest forms of automata, with:</p><ul class="list _bullet" id="z98xrh4_178"><li class="list__item" id="z98xrh4_180"><p>A finite number of internal states</p></li><li class="list__item" id="z98xrh4_181"><p>Input processing consisting of a sequence of symbols</p></li><li class="list__item" id="z98xrh4_182"><p>Transitions between states based on current state and input</p></li></ul><section class="chapter"><h3 id="definition" data-toc="definition">Definition</h3><p id="z98xrh4_183">A finite automaton (FA) is defined by the tuple M = (Q, &Sigma;, &delta;, q₀, F) where:</p><ul class="list _bullet" id="z98xrh4_184"><li class="list__item" id="z98xrh4_185"><p>Q is a finite set of internal states</p></li><li class="list__item" id="z98xrh4_186"><p>&Sigma; is the input alphabet</p></li><li class="list__item" id="z98xrh4_187"><p>&delta; is the transition function</p></li><li class="list__item" id="z98xrh4_188"><p>q₀ &isin; Q is the initial state</p></li><li class="list__item" id="z98xrh4_189"><p>F &sube; Q is a set of final states</p></li></ul></section></section><section class="chapter"><h2 id="dfas-vs-nfas" data-toc="dfas-vs-nfas">DFAs vs. NFAs</h2><section class="chapter"><h3 id="deterministic-finite-automata-dfas" data-toc="deterministic-finite-automata-dfas">Deterministic Finite Automata (DFAs)</h3><ul class="list _bullet" id="z98xrh4_192"><li class="list__item" id="z98xrh4_193"><p>Exactly one transition for each state and input symbol</p></li><li class="list__item" id="z98xrh4_194"><p>No &epsilon;-transitions allowed</p></li><li class="list__item" id="z98xrh4_195"><p>Easy to implement and execute</p></li></ul></section><section class="chapter"><h3 id="non-deterministic-finite-automata-nfas" data-toc="non-deterministic-finite-automata-nfas">Non-deterministic Finite Automata (NFAs)</h3><ul class="list _bullet" id="z98xrh4_196"><li class="list__item" id="z98xrh4_198"><p>Multiple transitions for each state-input pair allowed</p></li><li class="list__item" id="z98xrh4_199"><p>&epsilon;-transitions are allowed</p></li><li class="list__item" id="z98xrh4_200"><p>Undefined transitions possible</p></li><li class="list__item" id="z98xrh4_201"><p>Simpler to express from REs</p></li></ul><p id="z98xrh4_197">DFAs and NFAs are equally powerful - for any NFA, we can find an equivalent DFA, and vice versa.</p></section></section><section class="chapter"><h2 id="thompson-s-construction-re-nfa" data-toc="thompson-s-construction-re-nfa">Thompson's Construction (RE &rarr; NFA)</h2><p id="z98xrh4_202">Thompson's Construction is an algorithm to convert REs to NFAs:</p><ol class="list _decimal" id="z98xrh4_203" type="1"><li class="list__item" id="z98xrh4_206"><p>Construct NFA for each symbol and operator of the RE</p></li><li class="list__item" id="z98xrh4_207"><p>Glue them with &epsilon;-transitions in precedence order of RE operators</p></li></ol><section class="chapter"><h3 id="inductive-basis" data-toc="inductive-basis">Inductive Basis</h3><p id="z98xrh4_208">NFAs for primitive regular expressions (&empty;, &epsilon;, a)</p></section><section class="chapter"><h3 id="inductive-step" data-toc="inductive-step">Inductive Step</h3><p id="z98xrh4_209">For REs r₁ and r₂ with corresponding NFAs N₁ and N₂, we can build NFAs for:</p><ul class="list _bullet" id="z98xrh4_210"><li class="list__item" id="z98xrh4_211"><p>(r₁)</p></li><li class="list__item" id="z98xrh4_212"><p>r₁|r₂ (union)</p></li><li class="list__item" id="z98xrh4_213"><p>r₁r₂ (concatenation)</p></li><li class="list__item" id="z98xrh4_214"><p>r₁* (Kleene closure)</p></li></ul></section></section><section class="chapter"><h2 id="subset-construction-nfa-dfa" data-toc="subset-construction-nfa-dfa">Subset Construction (NFA &rarr; DFA)</h2><p id="z98xrh4_215">The Subset Construction algorithm converts an NFA to an equivalent DFA:</p><ol class="list _decimal" id="z98xrh4_216" type="1"><li class="list__item" id="z98xrh4_217"><p>Each state in the DFA corresponds to a set of states in the NFA</p></li><li class="list__item" id="z98xrh4_218"><p>The initial state of the DFA is the &epsilon;-closure of the initial state of the NFA</p></li><li class="list__item" id="z98xrh4_219"><p>For each state S in the DFA and each input symbol <code class="code" id="z98xrh4_220">a</code>, compute the &epsilon;-closure of the set of states reachable from S on input a</p></li></ol></section><section class="chapter"><h2 id="implementing-lexical-analyzers" data-toc="implementing-lexical-analyzers">Implementing Lexical Analyzers</h2><p id="z98xrh4_221">To convert token specifications to code:</p><ol class="list _decimal" id="z98xrh4_222" type="1"><li class="list__item" id="z98xrh4_225"><p>Define regular expressions for each token type</p></li><li class="list__item" id="z98xrh4_226"><p>Convert REs to NFAs using Thompson's Construction</p></li><li class="list__item" id="z98xrh4_227"><p>Convert NFAs to a DFA using Subset Construction</p></li><li class="list__item" id="z98xrh4_228"><p>Implement the DFA in code</p></li></ol><p id="z98xrh4_223">When implementing a scanner, two important rules are followed:</p><ol class="list _decimal" id="z98xrh4_224" type="1"><li class="list__item" id="z98xrh4_229"><p>The longest possible match is taken</p></li><li class="list__item" id="z98xrh4_230"><p>There is a priority among patterns (e.g., keywords take precedence over identifiers)</p></li></ol></section><div class="last-modified">Last modified: 13 March 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="compiler-01.html" class="navigation-links__prev">01. Introduction</a><a href="compiler-03.html" class="navigation-links__next">03. Lexical Analyzer 2</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>